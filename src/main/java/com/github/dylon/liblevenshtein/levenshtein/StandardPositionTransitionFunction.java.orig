package com.github.dylon.liblevenshtein.levenshtein;

/**
 * Transitions a standard, Levenshtein position to all possible positions, given
 * a set of parameters.
 * @author Dylon Edwards
 * @since 2.1.0
 */
public class StandardPositionTransitionFunction
  extends AbstractPositionTransitionFunction {

  private static final long serialVersionUID = 1L;

  /**
   * {@inheritDoc}
   */
  @Override
  public IState of(
      final int n,
      final int[] position,
      final boolean[] characteristicVector,
      final int offset) {

    final int i = position[0];
    final int e = position[1];
    final int h = i - offset;
    final int w = characteristicVector.length;

    // The edit distance is not below its maximum, allowed value.
    if (e < n) {
      // Consider any character before the last one of the spelling candidate
      if (h <= w - 2) {
        final int a = (n - e < Integer.MAX_VALUE)
          ? n - e + 1
          : Integer.MAX_VALUE;
        final int b = w - h;
        final int k = a < b ? a : b;
        final int j = indexOf(characteristicVector, k, h);

        if (0 == j) {
          return stateFactory.build(
<<<<<<< f79c66ba903206f001bc8095e41d9430f5c76ad5
              positionFactory.build(1 + i, e)
          );
=======
              // [No Error]: Increment the index by one; leave the error alone.
              positionFactory.build((1 + i), e));
>>>>>>> Annotates StandardPositionTransitionFunction with descriptions of its transitions; adds AssertJ for unit tests; renames levenshtein.proto to liblevelshtein.proto; replaces tabs in source with two spaces
        }

        if (j > 0) {
          return stateFactory.build(
<<<<<<< f79c66ba903206f001bc8095e41d9430f5c76ad5
              positionFactory.build(i, e + 1),
              positionFactory.build(i + 1, e + 1),
              positionFactory.build(i + j + 1, e + j)
          );
=======
              // [Insertion|Deletion]: Leave the index alone; increment the
              // error by one.
              positionFactory.build(i, (e + 1)),
              // [Substitution]: Increment both the index and error by one.
              positionFactory.build((i + 1), (e + 1)),
              // [Substitution]: Increment the index by one-more than the number
              // of substitutions; increment the error by the number of
              // substitutions.
              positionFactory.build((i + j + 1), (e + j)));
>>>>>>> Annotates StandardPositionTransitionFunction with descriptions of its transitions; adds AssertJ for unit tests; renames levenshtein.proto to liblevelshtein.proto; replaces tabs in source with two spaces
        }

        // else, j < 0
        return stateFactory.build(
<<<<<<< f79c66ba903206f001bc8095e41d9430f5c76ad5
            positionFactory.build(i, e + 1),
            positionFactory.build(i + 1, e + 1)
        );
=======
            // [Insertion|Deletion]: Leave the index alone; increment the error
            // by one.
            positionFactory.build(i, (e + 1)),
            // [Substitution]: Increment both the index and error by one.
            positionFactory.build((i + 1), (e + 1)));
>>>>>>> Annotates StandardPositionTransitionFunction with descriptions of its transitions; adds AssertJ for unit tests; renames levenshtein.proto to liblevelshtein.proto; replaces tabs in source with two spaces
      }

      // Consider the last character of the spelling candidate
      if (h == w - 1) {
        if (characteristicVector[h]) {
          return stateFactory.build(
<<<<<<< f79c66ba903206f001bc8095e41d9430f5c76ad5
              positionFactory.build(i + 1, e)
          );
        }

        return stateFactory.build(
            positionFactory.build(i, e + 1),
            positionFactory.build(i + 1, e + 1)
        );
=======
              // [No Error]: Increment the index by one; leave the error alone.
              positionFactory.build((i + 1), e));
        }

        return stateFactory.build(
            // [Insertion|Deletion]: Leave the index alone; increment the error
            // by one.
            positionFactory.build(i, (e + 1)),
            // [Substitution]: Increment both the index and error by one.
            positionFactory.build((i + 1), (e + 1)));
>>>>>>> Annotates StandardPositionTransitionFunction with descriptions of its transitions; adds AssertJ for unit tests; renames levenshtein.proto to liblevelshtein.proto; replaces tabs in source with two spaces
      }

      // else, h == w
      return stateFactory.build(
<<<<<<< f79c66ba903206f001bc8095e41d9430f5c76ad5
          positionFactory.build(i, e + 1)
      );
=======
          // [Insertion|Deletion]: Leave the index alone; increment the error by
          // one.
          positionFactory.build(i, (e + 1)));
>>>>>>> Annotates StandardPositionTransitionFunction with descriptions of its transitions; adds AssertJ for unit tests; renames levenshtein.proto to liblevelshtein.proto; replaces tabs in source with two spaces
    }

    // The edit distance is at its maximum, allowed value.  Only consider this
    // spelling candidate if there is no error at the index of its current term.
    if ((e == n) && (h <= w - 1) && characteristicVector[h]) {
      return stateFactory.build(
<<<<<<< f79c66ba903206f001bc8095e41d9430f5c76ad5
          positionFactory.build(i + 1, n)
      );
=======
          // [No Error]: Increment the index by one; leave the error alone.
          positionFactory.build((i + 1), n));
>>>>>>> Annotates StandardPositionTransitionFunction with descriptions of its transitions; adds AssertJ for unit tests; renames levenshtein.proto to liblevelshtein.proto; replaces tabs in source with two spaces
    }

    // [Too Many Errors]: The edit distance has exceeded the max distance for
    // the candidate term.
    return null;
  }
}
