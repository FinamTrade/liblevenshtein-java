apply plugin: 'java'
apply plugin: 'findbugs'
apply plugin: 'maven-publish'

repositories {
  mavenCentral()
}

group = 'com.github.dylon'
archivesBaseName = name
version = '2.1.0'

description = 'A library for generating Finite State Transducers based on Levenshtein Automata (keywords: fuzzy search; distance; metric; levenshtein; spelling correction; approximate string matching; automata; information retrieval; transducer).'

sourceCompatibility = 1.8
targetCompatibility = 1.8

def srcJava = "$projectDir/src/main/java"
def srcDelomboked = "$buildDir/src-delomboked/main/java"

ext {
  def groupPart = group.replaceAll('\\.', '/')
  def pomFileName = "${name}-${version}.pom"
  localRepo = file("$buildDir/repo")
  localRepoArtifactDir = file("${localRepo}/${groupPart}/${name}/${version}")
  pomFile = file("${localRepoArtifactDir}/${pomFileName}")
  sonatypeUsername = ""
  sonatypePassword = ""
}

configurations {
  shell
  pom
}

dependencies {
  compile 'com.google.code.findbugs:annotations:3.0.0'
  compile 'org.projectlombok:lombok:1.16.4'
  compile 'org.apache.commons:commons-lang3:3.4'
  compile 'it.unimi.dsi:fastutil:7.0.6'
  compile 'com.google.guava:guava:18.0'
  testCompile 'org.testng:testng:6.9.4'
  shell 'commons-cli:commons-cli:1.3.1'
  shell('jline:jline:2.12.1') {
    exclude(group: 'junit', module: 'junit')
  }
  shell 'org.codehaus.groovy:groovy-groovysh:2.4.3'
}

tasks.withType(JavaCompile) {
  options.compilerArgs << "-Xlint:unchecked"
}

test {
  useTestNG()

  testLogging {
    exceptionFormat "full"
    showStandardStreams true
    showExceptions true
    showStackTraces true
  }
}

// create syntastic classpath files
task syntastic {
  description = 'Dumps the classpaths a file that can be read by Syntastic.vim'
  doLast {
    def classpathFiles = new HashSet<String>()
    def addJars = { proj ->
      proj.configurations.each { conf ->
        conf.each { jar ->
          classpathFiles.add(jar)
        }
      }
      proj.sourceSets.each { srcSet ->
        srcSet.java.srcDirs.each { dir ->
          println dir.absolutePath
          classpathFiles.add(dir.absolutePath)
        }
      }
    }
    getChildProjects().each { proj ->
      addJars(proj.value)
    }
    addJars(rootProject)

    // create .vimrc.local
    def vimrc = new File(rootProject.projectDir.absolutePath + "/.vimrc.local")

    classpathFiles << rootProject.projectDir.absolutePath + "/build/classes/main"
    classpathFiles << rootProject.projectDir.absolutePath + "/build/classes/test"

    vimrc.text = """\
  let g:syntastic_java_javac_classpath = '${classpathFiles.collect().join(":")}'
  """

    println "Created .vimrc.local, don't forget to source this in your vim config"
  }
}

task(shell, dependsOn: 'classes') {
  description =
    'Groovy repl with this project and all its dependencies on the $CLASSPATH'

  doLast {
    def classpath = sourceSets.main.runtimeClasspath + configurations.shell

    def command = [
      'java',
      '-cp', classpath.collect().join(System.getProperty('path.separator')),
      'org.codehaus.groovy.tools.shell.Main',
      '--color'
    ]

    def proc = new ProcessBuilder(command)
      .redirectOutput(ProcessBuilder.Redirect.INHERIT)
      .redirectInput(ProcessBuilder.Redirect.INHERIT)
      .redirectError(ProcessBuilder.Redirect.INHERIT)
      .start()

    proc.waitFor()

    if (0 != proc.exitValue()) {
      throw new RuntimeException("shell exited with status: ${proc.exitValue()}")
    }
  }
}

tasks.withType(FindBugs) {
  reports {
    xml.enabled = false
    html.enabled = true
  }
}

task sourceJar(type: Jar) {
  classifier = 'sources'
  from file(srcDelomboked)
}

task javadocJar(type: Jar, dependsOn: [javadoc, classes]) {
  classifier = 'javadoc'
  from javadoc.destinationDir
}

artifacts {
  archives sourceJar
  archives javadocJar
  if (pomFile.exists()) {
    pom pomFile
  }
}

def getPomSignature() {
  return configurations.pom.allArtifacts
    .collect{ file("${it.file.path}.asc") }[0]
}

def getSignatureFiles() {
  def allFiles = configurations.archives.allArtifacts
    .collect { file("${it.file.path}.asc") }
    .findAll { it.exists() }

  def retval = []

  def signedSources = allFiles.find { it.name.contains("-sources") }
  if (null != signedSources) {
    retval << [archive: signedSources, classifier: 'sources', extension: 'jar.asc']
  }

  def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
  if (null != signedJavadoc) {
    retval << [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc']
  }

  def signedJars = (allFiles - [signedSources, signedJavadoc])
  if ( ! signedJars.isEmpty()) {
    retval << [archive: signedJars[0], classifier: null, extension: 'jar.asc']
  }

  return retval
}

def artifactTaskName(artifact) {
  return "sign:${artifact.file}"
}

def signArtifact(artifact) {
  def taskName = artifactTaskName(artifact)
  task "$taskName" (type: Exec) {
    commandLine 'gpg2', '--batch', '--yes', '-ab', artifact.file
    doFirst { println commandLine }
    doLast {
      def signature = file("${artifact.file}.asc")
      if (localRepoArtifactDir.exists() && signature.exists()) {
        ant.copy(
          file: signature,
          todir: localRepoArtifactDir)
      }
    }
  }
}

def jarFilter = {it.file.name =~ /\.jar$/}

configurations.archives.allArtifacts
  .findAll(jarFilter)
  .each(this.&signArtifact)

configurations.pom.allArtifacts.each(this.&signArtifact)

task signPom << {
  configurations.pom.allArtifacts
    .collect(this.&artifactTaskName)
    .each { tasks."$it".execute() }
}

task signJars(dependsOn: [jar, javadocJar, sourceJar]) << {
  configurations.archives.allArtifacts
    .findAll(jarFilter)
    .collect(this.&artifactTaskName)
    .each { tasks."$it".execute() }
}

if (project.ext.pomFile.exists()) {
  tasks.publish.dependsOn signJars
  tasks.publish.dependsOn signPom
}
else {
  tasks.publish.dependsOn signJars
}

def pomSignature = getPomSignature()

//if (project.gradle.startParameter.taskNames.contains('publish')
    //&& pomFile.exists()
    //&& pomSignature.exists()) {
  //def console = System.console()
  //console.printf("\nSonatype OSSRH Credentials:\n")
  //sonatypeUsername = console.readLine("Username: ")
  //sonatypePassword = console.readPassword("Password: ")
//}

publishing {
  repositories {
    maven {
      //if (pomFile.exists() && pomSignature.exists()) {
        //def sonatypeUrl = "https://oss.sonatype.org/content/repositories/snapshots"
        //def sonatypeUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2"

        //println("Uploading to $sonatypeUrl")
        //url sonatypeUrl
        //credentials {
          //username = sonatypeUsername
          //password = sonatypePassword
        //}
      //}
      //else {
        url localRepo
      //}
    }
  }
  publications {
    gpgJars (MavenPublication) {
      getSignatureFiles().each { signature ->
        artifact (signature.archive) {
          classifier = signature.classifier
          extension  = signature.extension
        }
      }
    }
    if (pomFile.exists() && pomSignature.exists()) {
      gpgPom (MavenPublication) {
        artifact (pomSignature) {
          classifier = null
          extension = 'pom.asc'
        }
      }
    }
    jar (MavenPublication) {
      from components.java
      artifact (javadocJar) {
        classifier = 'javadoc'
      }
      artifact (sourceJar) {
        classifier = 'sources'
      }
      pom.withXml {
        asNode().children().last() + {
          resolveStrategy = Closure.DELEGATE_FIRST
          name rootProject.name
          inceptionYear '2014'
          description rootProject.description
          url 'https://github.com/universal-automata/liblevenshtein-java/'
          packaging 'jar'
          licenses {
            license {
              name 'MIT License'
              url 'http://www.opensource.org/licenses/mit-license.php'
              distribution 'repo'
            }
          }
          developers {
            developer {
              id 'dylon'
              name 'Dylon Edwards'
              email 'dylon.edwards@gmail.com'
              url 'https://github.com/dylon'
            }
          }
          issueManagement {
            system 'GitHub Issues'
            url 'https://github.com/universal-automata/liblevenshtein-java/issues'
          }
          scm {
            url 'https://github.com/universal-automata/liblevenshtein-java'
            connection 'scm:git:https://github.com/universal-automata/liblevenshtein-java.git'
            developerConnection 'scm:git:git@github.com:universal-automata/liblevenshtein-java.git'
          }
        }
      }
    }
  }
}

task delombok {
  dependsOn configurations.compile.getTaskDependencyFromProjectDependency(true, "compileJava")

  // Make sure the delombok directory exists ...
  file(srcDelomboked).mkdirs()

  inputs.files file(srcJava)
  outputs.dir file(srcDelomboked)

  doLast {
    ant.taskdef(
      name: 'delombok',
      classname: 'lombok.delombok.ant.Tasks$Delombok',
      classpath: configurations.compile.asPath)
    ant.delombok(
      from: srcJava,
      to: srcDelomboked,
      classpath: configurations.compile.asPath)
  }
}

tasks.javadoc {
  dependsOn delombok
  source = new FileNameFinder().getFileNames(srcDelomboked, '**/*.java')
  options.optionFiles << file('javadoc.options')
}
