plugins {
  // Supported Plugins
  id 'checkstyle'
  id 'findbugs'
  id 'jacoco'
  id 'java'
  id 'maven-publish'

  // Third Party Plugins
  id 'com.github.kt3k.coveralls' version '2.6.3'
  id 'com.google.protobuf' version '0.7.6'
  id 'org.standardout.versioneye' version '1.2.0'
}

repositories {
  mavenCentral()
  jcenter()
}

group = 'com.github.dylon'
archivesBaseName = name
version = '2.2.1' // http://semver.org/

description = 'A library for generating Finite State Transducers based on Levenshtein Automata (keywords: fuzzy search; distance; metric; levenshtein; spelling correction; approximate string matching; automata; information retrieval; transducer).'

sourceCompatibility = 1.8
targetCompatibility = 1.8

ext {
  srcJava = "$projectDir/src/main/java"
  srcDelomboked = "$buildDir/src-delomboked/main/java"

  def groupPart = group.replaceAll('\\.', '/')
  def pomFileName = "${name}-${version}.pom"
  localRepo = file("$buildDir/repo")
  localRepoArtifactDir = file("${localRepo}/${groupPart}/${name}/${version}")
  pomFile = file("${localRepoArtifactDir}/${pomFileName}")

  //def sonatypeUrl = "https://oss.sonatype.org/content/repositories/snapshots"
  //def sonatypeUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2"
  sonatypeUsername = ""
  sonatypePassword = ""

  wikidocDir = file("${projectDir}/wiki")
}

configurations {
  shell
  pom
}

sourceSets {
  task
}

findbugs {
  excludeFilter = file("$rootProject.projectDir/config/findbugs/exclude-filter.xml")
}

protobuf {
  protoc {
    artifact = "com.google.protobuf:protoc:3.0.0-beta-2"
  }
}

dependencies {
  compile 'com.google.code.findbugs:annotations:3.0.1'
  compile 'com.google.guava:guava:19.0'
  compile 'com.google.protobuf:protobuf-java-util:3.0.0-beta-2'
  compile 'com.google.protobuf:protobuf-java:3.0.0-beta-2'
  compile 'it.unimi.dsi:fastutil:7.0.12'
  compile 'org.apache.commons:commons-lang3:3.4'
  compile 'org.projectlombok:lombok:1.16.8'
  compile 'org.slf4j:slf4j-api:1.7.21'

  taskCompile 'com.google.code.findbugs:annotations:3.0.1'
  taskCompile 'com.google.guava:guava:19.0'
  taskCompile 'commons-cli:commons-cli:1.3.1'
  taskCompile 'org.antlr:ST4:4.0.8'
  taskCompile 'org.projectlombok:lombok:1.16.8'
  taskCompile 'org.slf4j:slf4j-api:1.7.21'

  taskRuntime 'ch.qos.logback:logback-classic:1.1.7'
  taskRuntime 'org.codehaus.groovy:groovy-all:2.4.6'

  testCompile 'org.assertj:assertj-core:3.4.1'
  testCompile 'org.mockito:mockito-all:1.10.19'
  testCompile 'org.testng:testng:6.9.11'

  testRuntime 'ch.qos.logback:logback-classic:1.1.7'
  testRuntime 'org.codehaus.groovy:groovy-all:2.4.6'

  // JaCoCo (Plugin)
  jacocoAgent 'org.jacoco:org.jacoco.agent:0.7.6.201602180812'
  jacocoAnt 'org.jacoco:org.jacoco.ant:0.7.6.201602180812'

  // Checkstyle (Plugin)
  checkstyle 'com.puppycrawl.tools:checkstyle:6.17'

  shell 'commons-cli:commons-cli:1.3.1'
  shell('jline:jline:2.14.1') {
    exclude(group: 'junit', module: 'junit')
  }
  shell 'org.codehaus.groovy:groovy-groovysh:2.4.6'
}

jacocoTestReport {
  reports {
    xml.enabled = true // coveralls plugin depends on xml format report
    html.enabled = true
  }
  afterEvaluate {
    classDirectories = files(classDirectories.files.collect {
      fileTree(
        dir: it,
        exclude: [
          '**/LibLevenshteinProtos*'
        ]
      )
    })
  }
}

tasks.withType(JavaCompile) {
  options.compilerArgs << "-Xlint:all"
}

test {
  useTestNG() {
    // Run as many tests in-parallel as there are CPU cores
    parallel 'methods'
    threadCount Runtime.getRuntime().availableProcessors()
  }

  testLogging {
    exceptionFormat "full"
    showStandardStreams true
    showExceptions true
    showStackTraces true
  }
}

def exec(classpath, mainClass, args=[]) {
  def command = [
    'java',
    '-cp', classpath.asPath,
    mainClass
  ] + args

  def proc = new ProcessBuilder(command)
    .redirectOutput(ProcessBuilder.Redirect.INHERIT)
    .redirectInput(ProcessBuilder.Redirect.INHERIT)
    .redirectError(ProcessBuilder.Redirect.INHERIT)
    .start()

  proc.waitFor()

  if (0 != proc.exitValue()) {
    throw new RuntimeException("shell exited with status: ${proc.exitValue()}")
  }
}

def execTask(mainClass, args=[]) {
  def classpath = configurations.taskRuntime
  classpath += files(sourceSets.task.output.classesDir)
  classpath += files(sourceSets.task.output.resourcesDir)
  exec(classpath, mainClass, args + [
    "--group-id", rootProject.group,
    "--artifact-id", rootProject.name,
    "--version", rootProject.version,
    "--gradle-version", gradle.gradleVersion,
    "--java-source-version", sourceCompatibility.toString(),
    "--java-target-version", targetCompatibility.toString()
  ])
}

task(shell, dependsOn: classes) {
  description =
    'Groovy repl with this project and all its dependencies on the $CLASSPATH'

  doLast {
    def classpath = configurations.shell
    classpath += files(sourceSets.task.output.classesDir)
    classpath += files(sourceSets.task.output.resourcesDir)
    sourceSets.each() {classpath += it.runtimeClasspath}
    exec(classpath, 'org.codehaus.groovy.tools.shell.Main', ['--color'])
  }
}

// create syntastic classpath files
task syntastic(dependsOn: taskClasses) {
  description = 'Dumps the classpaths a file that can be read by Syntastic.vim'
  doLast {
    def classpath = configurations.taskRuntime
    classpath += files(sourceSets.task.output.classesDir)
    classpath += files(sourceSets.task.output.resourcesDir)
    sourceSets.each() {classpath += it.runtimeClasspath}

    def configPath = "${projectDir}/.vimrc.local".toString()

    execTask('com.github.dylon.liblevenshtein.task.GenerateSyntasticConfig', [
      "--classpath", classpath.asPath,
      "--config-path", configPath
    ])
  }
}

task wikidoc(dependsOn: taskClasses) {
  description = 'Generates GitHub, wiki documentation'
  doLast {
    execTask('com.github.dylon.liblevenshtein.task.GenerateWikidoc', [
      "--wiki-path", wikidocDir.path
    ])
  }
}

task readme(dependsOn: taskClasses) {
  description = 'Keeps the README.md up-to-date'
  doLast {
    execTask('com.github.dylon.liblevenshtein.task.GenerateReadme', [
      "--readme-path", "$projectDir/README.md".toString()
    ])
  }
}

tasks.withType(FindBugs) {
  reports {
    xml.enabled = false
    html.enabled = true
  }
}

task sourceJar(type: Jar) {
  classifier = 'sources'
  from file(srcDelomboked)
}

task javadocJar(type: Jar, dependsOn: [javadoc, classes]) {
  classifier = 'javadoc'
  from javadoc.destinationDir
}

artifacts {
  archives sourceJar
  archives javadocJar
  if (pomFile.exists()) {
    pom pomFile
  }
}

def getPomSignature() {
  return configurations.pom.allArtifacts
    .collect{ file("${it.file.path}.asc") }[0]
}

def getSignatureFiles() {
  def allFiles = configurations.archives.allArtifacts
    .collect { file("${it.file.path}.asc") }
    .findAll { it.exists() }

  def retval = []

  def signedSources = allFiles.find { it.name.contains("-sources") }
  if (null != signedSources) {
    retval << [archive: signedSources, classifier: 'sources', extension: 'jar.asc']
  }

  def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
  if (null != signedJavadoc) {
    retval << [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc']
  }

  def signedJars = (allFiles - [signedSources, signedJavadoc])
  if ( ! signedJars.isEmpty()) {
    retval << [archive: signedJars[0], classifier: null, extension: 'jar.asc']
  }

  return retval
}

def artifactTaskName(artifact) {
  return "sign:${artifact.file}"
}

def signArtifact(artifact) {
  def taskName = artifactTaskName(artifact)
  task "$taskName" (type: Exec) {
    commandLine 'gpg2', '--batch', '--yes', '-ab', artifact.file
    doFirst { println commandLine }
    doLast {
      def signature = file("${artifact.file}.asc")
      if (localRepoArtifactDir.exists() && signature.exists()) {
        ant.copy(
          file: signature,
          todir: localRepoArtifactDir)
      }
    }
  }
}

def jarFilter = {it.file.name =~ /\.jar$/}

configurations.archives.allArtifacts
  .findAll(jarFilter)
  .each(this.&signArtifact)

configurations.pom.allArtifacts.each(this.&signArtifact)

task signPom << {
  configurations.pom.allArtifacts
    .collect(this.&artifactTaskName)
    .each { tasks."$it".execute() }
}

task signJars(dependsOn: [jar, javadocJar, sourceJar]) << {
  configurations.archives.allArtifacts
    .findAll(jarFilter)
    .collect(this.&artifactTaskName)
    .each { tasks."$it".execute() }
}

if (project.ext.pomFile.exists()) {
  tasks.publish.dependsOn signJars
  tasks.publish.dependsOn signPom
}
else {
  tasks.publish.dependsOn signJars
}

def pomSignature = getPomSignature()

//if (project.gradle.startParameter.taskNames.contains('publish')
    //&& pomFile.exists()
    //&& pomSignature.exists()) {
  //def console = System.console()
  //console.printf("\nSonatype OSSRH Credentials:\n")
  //sonatypeUsername = console.readLine("Username: ")
  //sonatypePassword = console.readPassword("Password: ")
//}

publishing {
  repositories {
    maven {
      //if (pomFile.exists() && pomSignature.exists()) {
        //println("Uploading to $sonatypeUrl")
        //url sonatypeUrl
        //credentials {
          //username = sonatypeUsername
          //password = sonatypePassword
        //}
      //}
      //else {
        url localRepo
      //}
    }
  }
  publications {
    gpgJars (MavenPublication) {
      getSignatureFiles().each { signature ->
        artifact (signature.archive) {
          classifier = signature.classifier
          extension  = signature.extension
        }
      }
    }
    if (pomFile.exists() && pomSignature.exists()) {
      gpgPom (MavenPublication) {
        artifact (pomSignature) {
          classifier = null
          extension = 'pom.asc'
        }
      }
    }
    jar (MavenPublication) {
      from components.java
      artifact (javadocJar) {
        classifier = 'javadoc'
      }
      artifact (sourceJar) {
        classifier = 'sources'
      }
      pom.withXml {
        asNode().children().last() + {
          resolveStrategy = Closure.DELEGATE_FIRST
          name rootProject.name
          inceptionYear '2014'
          description rootProject.description
          url 'https://github.com/universal-automata/liblevenshtein-java/'
          packaging 'jar'
          licenses {
            license {
              name 'MIT License'
              url 'http://www.opensource.org/licenses/mit-license.php'
              distribution 'repo'
            }
          }
          developers {
            developer {
              id 'dylon'
              name 'Dylon Edwards'
              email 'dylon.edwards@gmail.com'
              url 'https://github.com/dylon'
            }
          }
          issueManagement {
            system 'GitHub Issues'
            url 'https://github.com/universal-automata/liblevenshtein-java/issues'
          }
          scm {
            url 'https://github.com/universal-automata/liblevenshtein-java'
            connection 'scm:git:https://github.com/universal-automata/liblevenshtein-java.git'
            developerConnection 'scm:git:git@github.com:universal-automata/liblevenshtein-java.git'
          }
        }
      }
    }
  }
}

task delombok {
  dependsOn configurations.compile.getTaskDependencyFromProjectDependency(true, "compileJava")

  // Make sure the delombok directory exists ...
  file(srcDelomboked).mkdirs()

  inputs.files file(srcJava)
  outputs.dir file(srcDelomboked)

  doLast {
    ant.taskdef(
      name: 'delombok',
      classname: 'lombok.delombok.ant.Tasks$Delombok',
      classpath: configurations.compile.asPath)
    ant.delombok(
      from: srcJava,
      to: srcDelomboked,
      classpath: configurations.compile.asPath)
  }
}

tasks.javadoc {
  dependsOn delombok
  source = new FileNameFinder().getFileNames("$buildDir", '**/*.java')
  options.optionFiles << file('javadoc.options')
}

task checkstyleMainHtml << {
  ant.xslt(
    in: checkstyleMain.reports.xml.destination,
    style: file("${projectDir}/config/checkstyle/checkstyle.xsl"),
    out: new File(checkstyleMain.reports.xml.destination.parent, 'main.html'))
}

task checkstyleTaskHtml << {
  ant.xslt(
    in: checkstyleTask.reports.xml.destination,
    style: file("${projectDir}/config/checkstyle/checkstyle.xsl"),
    out: new File(checkstyleTask.reports.xml.destination.parent, 'task.html'))
}

task checkstyleTestHtml << {
  ant.xslt(
    in: checkstyleTest.reports.xml.destination,
    style: file("${projectDir}/config/checkstyle/checkstyle.xsl"),
    out: new File(checkstyleTest.reports.xml.destination.parent, 'test.html'))
}

checkstyleMain.finalizedBy checkstyleMainHtml
checkstyleTask.finalizedBy checkstyleTaskHtml
checkstyleTest.finalizedBy checkstyleTestHtml
